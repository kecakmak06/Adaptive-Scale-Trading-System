{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 142, "column": 0}, "map": {"version":3,"sources":["file:///Users/kecakmak/Library/CloudStorage/OneDrive-TheOhioStateUniversity/Adaptive-Scalar-Trading-System/lib/alpaca-client.ts"],"sourcesContent":["\nimport Alpaca from \"@alpacahq/alpaca-trade-api\";\n\n// Initialize Alpaca client\n// Note: We use process.env directly. Ensure these are set in .env.local\nconst alpaca = new Alpaca({\n    keyId: process.env.NEXT_PUBLIC_ALPACA_API_KEY,\n    secretKey: process.env.NEXT_PUBLIC_ALPACA_API_SECRET,\n    paper: true, // Default to paper trading\n});\n\nexport interface AlpacaAccount {\n    id: string;\n    equity: string;\n    buying_power: string;\n    cash: string;\n    currency: string;\n    status: string;\n}\n\nexport interface AlpacaBar {\n    t: string; // Timestamp\n    o: number; // Open\n    h: number; // High\n    l: number; // Low\n    c: number; // Close\n    v: number; // Volume\n}\n\nexport class AlpacaClient {\n    async getAccount(): Promise<AlpacaAccount> {\n        try {\n            const account = await alpaca.getAccount();\n            return account;\n        } catch (error) {\n            console.error(\"Error fetching Alpaca account:\", error);\n            throw error;\n        }\n    }\n\n    async getBars(symbol: string, timeframe: string = \"1Day\", limit: number = 100): Promise<AlpacaBar[]> {\n        try {\n            // Manual Aggregation for unsupported timeframes on free plan\n            if ([\"1Week\", \"1Month\", \"12Month\"].includes(timeframe)) {\n                return this.getAggregatedBars(symbol, timeframe, limit);\n            }\n\n            // Calculate Start Date based on limit and timeframe to ensure we get enough data\n            // We go back enough units + buffer (for weekends/closed hours)\n            const now = new Date();\n            let lookbackMinutes = 0;\n\n            switch (timeframe) {\n                case \"1Min\": lookbackMinutes = limit * 2; break; // 2x buffer\n                case \"5Min\": lookbackMinutes = limit * 5 * 2; break;\n                case \"15Min\": lookbackMinutes = limit * 15 * 2; break;\n                case \"1Hour\": lookbackMinutes = limit * 60 * 2; break;\n                case \"1Day\": lookbackMinutes = limit * 24 * 60 * 2; break; // 2x for weekends\n                default: lookbackMinutes = limit * 24 * 60; // default to day-ish\n            }\n\n            // For small limits or intraday, ensure we don't go back too absurdly far, \n            // but for \"1Day\", ensuring 14 bars means going back ~20-30 days.\n            const start = new Date(now.getTime() - lookbackMinutes * 60000);\n\n            const bars: AlpacaBar[] = [];\n            const resp = alpaca.getBarsV2(symbol, {\n                timeframe: timeframe, // \"1Min\", \"5Min\", \"15Min\", \"1Day\"\n                start: start.toISOString(),\n                // limit: limit, // Do NOT pass limit to API if we want the LATEST. If we pass limit=14 with start=30days ago, we get the OLD 14 bars.\n                // We will fetch from start -> now, then slice.\n            });\n\n            for await (const b of resp) {\n                const bar = b as any;\n                bars.push({\n                    t: bar.Timestamp || bar.t,\n                    o: bar.OpenPrice || bar.o,\n                    h: bar.HighPrice || bar.h,\n                    l: bar.LowPrice || bar.l,\n                    c: bar.ClosePrice || bar.c,\n                    v: bar.Volume || bar.v,\n                });\n            }\n\n            // If we fetched too many, take the last 'limit'\n            return bars.slice(-limit);\n        } catch (error) {\n            console.error(`Error fetching bars for ${symbol}:`, error);\n            return [];\n        }\n    }\n\n    private async getAggregatedBars(symbol: string, timeframe: string, limit: number): Promise<AlpacaBar[]> {\n        // Fetch enough daily bars to aggregate\n        let multiplier = 7;\n        if (timeframe === \"1Month\") multiplier = 35; // Buffer for weekends/holidays\n        if (timeframe === \"12Month\") multiplier = 370;\n\n        // Cap at reasonable max (e.g. 3 years of dailies ~ 750 bars, 10 years ~ 2500)\n        // Alpaca pagination handles large requests automatically in getBarsV2 usually, \n        // but let's be safe.\n        const dailyLimit = Math.min(limit * multiplier, 3000);\n\n        const dailyBars = await this.getBars(symbol, \"1Day\", dailyLimit);\n\n        if (dailyBars.length === 0) return [];\n\n        const aggregatedPars: AlpacaBar[] = [];\n        let currentBar: AlpacaBar | null = null;\n\n        // Helper to get aggregation key\n        const getKey = (dateStr: string) => {\n            const date = new Date(dateStr);\n            if (timeframe === \"1Week\") {\n                // Get Monday of the week\n                const day = date.getDay(),\n                    diff = date.getDate() - day + (day == 0 ? -6 : 1); // adjust when day is sunday\n                const monday = new Date(date.setDate(diff));\n                return monday.toISOString().split('T')[0];\n            }\n            if (timeframe === \"1Month\") {\n                return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;\n            }\n            // 12Month (Year)\n            return `${date.getFullYear()}`;\n        }\n\n        // dailyBars come latest last usually, but let's sort to be sure\n        dailyBars.sort((a, b) => new Date(a.t).getTime() - new Date(b.t).getTime());\n\n        // Map key -> accumulated bar\n        const grouped = new Map<string, AlpacaBar>();\n\n        for (const bar of dailyBars) {\n            const key = getKey(bar.t);\n            if (!grouped.has(key)) {\n                grouped.set(key, { ...bar, t: key }); // Set timestamp to start of period (or close enough)\n            } else {\n                const existing = grouped.get(key)!;\n                existing.h = Math.max(existing.h, bar.h);\n                existing.l = Math.min(existing.l, bar.l);\n                existing.c = bar.c; // Close is the last bar's close\n                existing.v += bar.v;\n                // Open remains first Open\n            }\n        }\n\n        return Array.from(grouped.values()).slice(-limit); // Return last N aggregated bars\n    }\n\n    async getMarketStatus(): Promise<boolean> {\n        try {\n            const clock = await alpaca.getClock();\n            return clock.is_open;\n        } catch (err) {\n            return false;\n        }\n    }\n\n    async getSnapshot(symbol: string): Promise<any> {\n        try {\n            const snapshot = await alpaca.getSnapshot(symbol);\n            return snapshot;\n        } catch (error) {\n            console.error(`Error fetching snapshot for ${symbol}:`, error);\n            throw error;\n        }\n    }\n\n    async getLatestTrade(symbol: string): Promise<any> {\n        try {\n            const trade = await alpaca.getLatestTrade(symbol);\n            return trade;\n        } catch (error) {\n            console.error(`Error fetching latest trade for ${symbol}:`, error);\n            throw error;\n        }\n    }\n\n    async getAsset(symbol: string): Promise<any> {\n        try {\n            const asset = await alpaca.getAsset(symbol);\n            return asset;\n        } catch (error) {\n            console.error(`Error fetching asset info for ${symbol}:`, error);\n            throw error;\n        }\n    }\n\n    async submitOrder(order: { symbol: string; qty: number; side: \"buy\" | \"sell\"; type: \"market\" | \"limit\"; limitPrice?: number }): Promise<any> {\n        try {\n            const ord = await alpaca.createOrder({\n                symbol: order.symbol,\n                qty: order.qty,\n                side: order.side,\n                type: order.type,\n                time_in_force: \"day\",\n                limit_price: order.limitPrice,\n            });\n            return ord;\n        } catch (error) {\n            console.error(\"Error submitting order:\", error);\n            throw error;\n        }\n    }\n\n    async getPositions(): Promise<any[]> {\n        try {\n            const positions = await alpaca.getPositions();\n            return positions;\n        } catch (error) {\n            console.error(\"Error fetching positions:\", error);\n            return [];\n        }\n    }\n\n    async getOrders(status: \"open\" | \"closed\" | \"all\" = \"all\", limit: number = 50): Promise<any[]> {\n        try {\n            const orders = await alpaca.getOrders({\n                status: status,\n                limit: limit,\n                nested: true,\n            } as any);\n            return orders;\n        } catch (error) {\n            console.error(\"Error fetching orders:\", error);\n            return [];\n        }\n    }\n\n    async cancelOrder(orderId: string): Promise<void> {\n        try {\n            await alpaca.cancelOrder(orderId);\n        } catch (error) {\n            console.error(`Error cancelling order ${orderId}:`, error);\n            throw error;\n        }\n    }\n\n    async closePosition(symbol: string): Promise<void> {\n        try {\n            await alpaca.closePosition(symbol);\n        } catch (error) {\n            console.error(`Error closing position for ${symbol}:`, error);\n            throw error;\n        }\n    }\n}\n\nexport const alpacaClient = new AlpacaClient();\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 371, "column": 0}, "map": {"version":3,"sources":["file:///Users/kecakmak/Library/CloudStorage/OneDrive-TheOhioStateUniversity/Adaptive-Scalar-Trading-System/app/api/alpaca/snapshot/route.ts"],"sourcesContent":["\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { alpacaClient } from \"@/lib/alpaca-client\";\n\nexport async function GET(request: NextRequest) {\n    const searchParams = request.nextUrl.searchParams;\n    const symbol = searchParams.get(\"symbol\");\n\n    if (!symbol) {\n        return NextResponse.json({ error: \"Symbol is required\" }, { status: 400 });\n    }\n\n    try {\n        const [snapshot, asset] = await Promise.all([\n            alpacaClient.getSnapshot(symbol),\n            alpacaClient.getAsset(symbol)\n        ]);\n\n        return NextResponse.json({\n            snapshot,\n            asset\n        });\n    } catch (error: any) {\n        console.error(\"Snapshot API Error:\", error.message || error);\n        return NextResponse.json(\n            { error: error.message || \"Failed to fetch market data\" },\n            { status: 500 }\n        );\n    }\n}\n"],"names":[],"mappings":";;;;AACA;AACA;;;AAEO,eAAe,IAAI,OAAoB;IAC1C,MAAM,eAAe,QAAQ,OAAO,CAAC,YAAY;IACjD,MAAM,SAAS,aAAa,GAAG,CAAC;IAEhC,IAAI,CAAC,QAAQ;QACT,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAqB,GAAG;YAAE,QAAQ;QAAI;IAC5E;IAEA,IAAI;QACA,MAAM,CAAC,UAAU,MAAM,GAAG,MAAM,QAAQ,GAAG,CAAC;YACxC,yIAAY,CAAC,WAAW,CAAC;YACzB,yIAAY,CAAC,QAAQ,CAAC;SACzB;QAED,OAAO,gJAAY,CAAC,IAAI,CAAC;YACrB;YACA;QACJ;IACJ,EAAE,OAAO,OAAY;QACjB,QAAQ,KAAK,CAAC,uBAAuB,MAAM,OAAO,IAAI;QACtD,OAAO,gJAAY,CAAC,IAAI,CACpB;YAAE,OAAO,MAAM,OAAO,IAAI;QAA8B,GACxD;YAAE,QAAQ;QAAI;IAEtB;AACJ"}}]
}